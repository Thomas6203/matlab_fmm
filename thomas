tic; % 開始計時

global n
n = 4;

global max_particles
max_particles = 4*n^2;
mask(8192,8192)=0;
levelnum = 1;
cell={0}; 
[mask_quadtree, cell ]= initialize_quadtree(mask, levelnum, cell, ...
                                            normalized_boundary(mask));

%% Initialization
function normalized_boundary = normalized_boundary(matrix)
    %座標化矩陣的邊界 產生的陣列   

    normalized_boundary = [-1 1 -1 1];
end   %如果cell可以保持原矩陣元素的順序和位置，就可以不用頂點， %暫時不考慮
      

function [quadtree, cell] = initialize_quadtree(particles, levelnum, cell, boundary)
    % particles: 可能包含粒子的節點(矩陣)
    % boundary: 節點的邊界 [xmin xmax ymin ymax]
    % max_particles: 每個節點中最多能容納的粒子數
    %% cell 尚未能成功實現
    

    % 如果當前節點的粒子數量超過 max_particles，則分割區域
    count = nnz(particles(:)) ;
    % count = 0;
    % for i = 1: size(particles,1)
    %     for j = 1: size(particles,2)
    %         if particles(i,j) == 1
    %             count = count+1;
    %         end
    %     end
    % end
    global max_particles
    if count > max_particles %使用全域變數前也需要先宣告是global
        % 分割成四個區域

        if mod( size(particles,1), 2 ) == 1 %處理分隔點為小數的問題
            the_other_half_of_particles_rows = fix(size(particles,1)/2)+1;
        else
            the_other_half_of_particles_rows = size(particles,1)/2;
        end
        if mod( size(particles,2), 2 ) == 1
            the_other_half_of_particles_cols = fix(size(particles,2)/2)+1;
        else
            the_other_half_of_particles_cols = size(particles,2)/2;
        end
        
        cell = {};%mat2cell(particles,size(particles,1),size(particles,2));
        new_cell = mat2cell(particles, [fix(size(particles,1)/2), ...
                                        the_other_half_of_particles_rows ], ...
                                       [fix(size(particles,2)/2), ...
                                        the_other_half_of_particles_cols] );
        cell{1,1} = new_cell{1,1};
        cell{1,2} = new_cell{1,2};
        cell{2,1} = new_cell{2,1};
        cell{2,2} = new_cell{2,2};
        %cell是否能保有原本mask的全部元素?？                  

    %%
        quadtree = struct('children', {}, 'divided_particles', [], ...
                          'level', levelnum,'boundary', boundary) ;
        
        % % 分割成四個區域
        % [region1, region2, region3, region4] = split_boundary(boundary);

        % 根據位置將粒子分配到各個區域  
        %可能可以省略
        quadtree(1).divided_particles = new_cell{1,1};
        quadtree(2).divided_particles = new_cell{1,2};
        quadtree(3).divided_particles = new_cell{2,1};
        quadtree(4).divided_particles = new_cell{2,2};
        
        quadtree(1).level = levelnum;
        quadtree(2).level = levelnum;
        quadtree(3).level = levelnum;
        quadtree(4).level = levelnum;


        %處理邊界
        mid_x = (boundary(1) + boundary(2)) / 2;
        mid_y = (boundary(3) + boundary(4)) / 2;

        new_boundary1 = [boundary(1), mid_x, boundary(3), mid_y];
        new_boundary2 = [mid_x, boundary(2), boundary(3), mid_y];
        new_boundary3 = [boundary(1), mid_x, mid_y, boundary(4)];
        new_boundary4 = [mid_x, boundary(2), mid_y, boundary(4)];
        
        quadtree(1).boundary = [boundary(1), mid_x, boundary(3), mid_y];
        quadtree(2).boundary = [mid_x, boundary(2), boundary(3), mid_y];
        quadtree(3).boundary = [boundary(1), mid_x, mid_y, boundary(4)];
        quadtree(4).boundary = [mid_x, boundary(2), mid_y, boundary(4)];


        % 遞迴地為每個子區域建立四叉樹
        quadtree(1).children = initialize_quadtree(quadtree(1).divided_particles, ...
            levelnum + 1, cell{1,1}, new_boundary1);
        quadtree(2).children = initialize_quadtree(quadtree(2).divided_particles, ...
            levelnum + 1,cell{1,2},new_boundary2);
        quadtree(3).children = initialize_quadtree(quadtree(3).divided_particles, ...
            levelnum + 1,cell{2,1},new_boundary3);
        quadtree(4).children = initialize_quadtree(quadtree(4).divided_particles, ...
            levelnum + 1,cell{2,2},new_boundary4);
    else
        % 如果粒子數量在可接受範圍內，則不分割
        % 需要給個空集合才能在後續使用isempty!!
        quadtree = struct('children', {}, 'divided_particles', particles, ...
                          'level', levelnum,'boundary', boundary) ;
        quadtree(1).level = levelnum;
        quadtree(1).boundary = boundary;
        quadtree(1).divided_particles = particles;
        quadtree(1).children = {};
    end
end  




% U_list(400).node= (0);  %%需要使用global才有效
% U_list(400).cell= (0);
%V_list = struct('node', '', 'cell', {} );
% V_list(400).node= (0);
% V_list(400).cell= (0);

% U_list = pre_order_traversal(mask_quadtree);

% global U_counter_for_name %%為何會出現不會被下一句歸零的情況??????????
% U_counter_for_name = 0;

level_list = save_the_leaf_nodes_on_the_same_level(mask_quadtree);
 
function y = save_the_leaf_nodes_on_the_same_level(root)
%先用廣度優先演算法 存同level 的葉節點，並且省略元素全為0的葉節點

    level_list= struct('level', {} , 'cell', {} );
    % 初始化一個佇列來存放節點
    queue = {root};
    counter = 1;

    while ~isempty(queue)
        % 從佇列中取出第一個節點
        currentNode = queue{1};
        queue(1) = []; % 將取出的節點移除

        % % 顯示當前節點
        % disp(currentNode);

        % ignore_this = struct('name1',{},'name2',{});
        % ignore_this(1).name = 1;
        % U_list(counter).cell(1) = ignore_this(1);

        level_list(counter).level =  counter;
        if currentNode(1).level ~= counter
            counter = counter + 1;
        end

        have_runned = 0;%解決陣列還沒有元素前，不能使用end+1的問題
                        %並解決參數中的end+1語法，有一樣的資料型態甚至連結構變數都要相同的問題
                     
        % 檢查並加入子節點到佇列中
        if ~isempty(currentNode(1).children)
            queue{end + 1} = currentNode(1).children;
            if(nnz(currentNode(1).divided_particles) ~= 0)
                if have_runned == 0
                    level_list(counter).cell(1) = currentNode(1);
                    have_runned = have_runned + 1;
                else
                    level_list(counter).cell(end+1) = currentNode(1);
                end
            end
        end

        if length(currentNode) >= 2 && ~isempty(currentNode(2).children)
            queue{end + 1} = currentNode(2).children;      
            if(nnz(currentNode(2).divided_particles) ~= 0)
                if have_runned == 0
                    level_list(counter).cell(1) = currentNode(2);
                    have_runned = have_runned + 1;
                else
                    level_list(counter).cell(end+1) = currentNode(2);
                end
            end
        end

        if length(currentNode) >= 3 && ~isempty(currentNode(3).children)
            queue{end + 1} = currentNode(3).children;
            if(nnz(currentNode(3).divided_particles) ~= 0)
                if have_runned == 0
                    level_list(counter).cell(1) = currentNode(3);
                    have_runned = have_runned + 1;
                else
                    level_list(counter).cell(end+1) = currentNode(3);
                end
            end
        end

        if length(currentNode) >= 4 && ~isempty(currentNode(4).children)
            queue{end + 1} = currentNode(4).children;
            if(nnz(currentNode(4).divided_particles) ~= 0)
                if have_runned == 0
                    level_list(counter).cell(1) = currentNode(4);
                    have_runned = have_runned + 1;
                else
                    level_list(counter).cell(end+1) = currentNode(4);
                end
            end
        end
    end

    y = level_list;
end

% % 
% % 
% % Upward pass
% % function multipole_expansion = upward_pass(node)
% %     如果是葉節點，計算多極展開
% %     if isempty(node{})
% %         multipole_expansion = compute_multipole(node.particles);
% %     else
% %         否則，遞迴地計算每個子節點的多極展開，並合併結果
% %         multipole_expansion = 0;
% %         for i = 1:4
% %             child_expansion = upward_pass(node.children{i});
% %             multipole_expansion = merge_multipole(multipole_expansion, child_expansion);
% %         end
% %     end
% % end
% % 
% % 
% % function multipole = compute_multipole(particles)
% %     根據粒子的位置和劑量值計算多極展開
% %     此處可自訂 Chebyshev 插值或其他方法
% %     multipole = sum(particles(:, 3));  % 假設第三列是劑量值
% % end
% % 
% % 
% % function result = merge_multipole(parent_multipole, child_multipole)
% %     合併父節點和子節點的多極展開
% %     result = parent_multipole + child_multipole;
% % end
% % 
% % 
% % 
% 
% 
% 
% % %% Downward pass
% % function local_expansion = downward_pass(node, parent_local_expansion)
% %     % 計算當前節點的局部展開，從父節點向下傳遞
% %     if isempty(node.children)
% %         local_expansion = parent_local_expansion + compute_local(node.particles);
% %     else
% %         % 遞迴地對每個子節點進行局部展開的傳遞
% %         for i = 1:4
% %             node.children{i}.local_expansion = downward_pass(node.children{i}, parent_local_expansion);
% %         end
% %     end
% % end
% % 
% % function local = compute_local(particles)
% %     % 計算粒子的局部展開
% %     local = sum(particles(:, 3));  % 假設第三列是劑量值
% % end
% % 
% % 
% 
% 
% 
% 
% % %% Gather
% % function energy_distribution = gather(node)
% %     if isempty(node.children)
% %         % 如果是葉節點，返回能量分佈
% %         energy_distribution = compute_energy(node.particles);
% %     else
% %         % 否則，遞迴地收集每個子節點的能量分佈
% %         energy_distribution = 0;
% %         for i = 1:4
% %             energy_distribution = energy_distribution + gather(node.children{i});
% %         end
% %     end
% % end
% % 
% % function energy = compute_energy(particles)
% %     % 計算每個粒子的最終能量分佈
% %     % 假設能量與多極展開和局部展開的結果相關
% %     energy = sum(particles(:, 3));  % 假設第三列是劑量值
% % end
% 
elapsedTime = toc; % 結束計時並返回所花時間（秒）
fprintf('程式執行時間：%.2f 秒\n', elapsedTime);

