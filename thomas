tic; % 開始計時

global n
n = 4;

global max_particles
max_particles = 4*n^2;
mask(8192,8192)=0;
levelnum = 1;
cell={0}; 
[mask_quadtree, cell ]= initialize_quadtree(mask, levelnum, cell, ...
                                            normalized_boundary(mask));

%% Initialization
function normalized_boundary = normalized_boundary(matrix)
    %座標化矩陣的邊界 產生的陣列   

    normalized_boundary = [-1 1 -1 1];
end   %如果cell可以保持原矩陣元素的順序和位置，就可以不用頂點， %暫時不考慮
      

function [quadtree, cell] = initialize_quadtree(particles, levelnum, cell, boundary)
    % particles: 可能包含粒子的節點(矩陣)
    % boundary: 節點的邊界 [xmin xmax ymin ymax]
    % max_particles: 每個節點中最多能容納的粒子數
    %% cell 尚未能成功實現
    

    % 如果當前節點的粒子數量超過 max_particles，則分割區域
    count = nnz(particles(:)) ;
    % count = 0;
    % for i = 1: size(particles,1)
    %     for j = 1: size(particles,2)
    %         if particles(i,j) == 1
    %             count = count+1;
    %         end
    %     end
    % end
    global max_particles
    if count > max_particles %使用全域變數前也需要先宣告是global
        % 分割成四個區域

        if mod( size(particles,1), 2 ) == 1 %處理分隔點為小數的問題
            the_other_half_of_particles_rows = fix(size(particles,1)/2)+1;
        else
            the_other_half_of_particles_rows = size(particles,1)/2;
        end
        if mod( size(particles,2), 2 ) == 1
            the_other_half_of_particles_cols = fix(size(particles,2)/2)+1;
        else
            the_other_half_of_particles_cols = size(particles,2)/2;
        end
        
        cell = {};%mat2cell(particles,size(particles,1),size(particles,2));
        new_cell = mat2cell(particles, [fix(size(particles,1)/2), ...
                                        the_other_half_of_particles_rows ], ...
                                       [fix(size(particles,2)/2), ...
                                        the_other_half_of_particles_cols] );
        cell{1,1} = new_cell{1,1};
        cell{1,2} = new_cell{1,2};
        cell{2,1} = new_cell{2,1};
        cell{2,2} = new_cell{2,2};
        %cell是否能保有原本mask的全部元素?？                  

    %%
        quadtree = struct('children', {}, 'divided_particles', [], ...
                          'level', levelnum,'boundary', boundary) ;
        
        % % 分割成四個區域
        % [region1, region2, region3, region4] = split_boundary(boundary);

        % 根據位置將粒子分配到各個區域  
        %可能可以省略
        quadtree(1).divided_particles = new_cell{1,1};
        quadtree(2).divided_particles = new_cell{1,2};
        quadtree(3).divided_particles = new_cell{2,1};
        quadtree(4).divided_particles = new_cell{2,2};
        
        quadtree(1).level = levelnum;
        quadtree(2).level = levelnum;
        quadtree(3).level = levelnum;
        quadtree(4).level = levelnum;


        %處理邊界
        mid_x = (boundary(1) + boundary(2)) / 2;
        mid_y = (boundary(3) + boundary(4)) / 2;

        new_boundary1 = [boundary(1), mid_x, boundary(3), mid_y];
        new_boundary2 = [mid_x, boundary(2), boundary(3), mid_y];
        new_boundary3 = [boundary(1), mid_x, mid_y, boundary(4)];
        new_boundary4 = [mid_x, boundary(2), mid_y, boundary(4)];
        
        quadtree(1).boundary = [boundary(1), mid_x, boundary(3), mid_y];
        quadtree(2).boundary = [mid_x, boundary(2), boundary(3), mid_y];
        quadtree(3).boundary = [boundary(1), mid_x, mid_y, boundary(4)];
        quadtree(4).boundary = [mid_x, boundary(2), mid_y, boundary(4)];


        % 遞迴地為每個子區域建立四叉樹
        quadtree(1).children = initialize_quadtree(quadtree(1).divided_particles, ...
            levelnum + 1, cell{1,1}, new_boundary1);
        quadtree(2).children = initialize_quadtree(quadtree(2).divided_particles, ...
            levelnum + 1,cell{1,2},new_boundary2);
        quadtree(3).children = initialize_quadtree(quadtree(3).divided_particles, ...
            levelnum + 1,cell{2,1},new_boundary3);
        quadtree(4).children = initialize_quadtree(quadtree(4).divided_particles, ...
            levelnum + 1,cell{2,2},new_boundary4);
    else
        % 如果粒子數量在可接受範圍內，則不分割
        % 需要給個空集合才能在後續使用isempty!!
        quadtree = struct('children', {}, 'particles', particles);
    end

end  




% U_list(400).node= (0);  %%需要使用global才有效
% U_list(400).cell= (0);
%V_list = struct('node', '', 'cell', {} );
% V_list(400).node= (0);
% V_list(400).cell= (0);
pre_order_traversal(mask_quadtree);

global U_counter_for_name ;
U_counter_for_name = 0;


function y = pre_order_traversal(root_node)

U_list = struct('node', "", 'cell', {0 0 0 0} ); 
    global U_counter_for_name ;

    if isempty(root_node(1).children) == 0

        %%U_list: 與一個小方塊四周的任一邊界相鄰者 且層級相同者
        %如何對於一個節點，讀取或列出所有與其相同層級的節點?? done?

        have_runned = 0;
        for i = 1:4
            counter_for_cell_of_I  = 0;
            if (    root_node(i).level == root_node(1).level...
                    && ...
                    (root_node(i).boundary(1) == root_node(1).boundary(1)|| ...
                    root_node(i).boundary(2) == root_node(1).boundary(1)||...
                    root_node(i).boundary(1) == root_node(1).boundary(2)|| ...
                    root_node(i).boundary(2) == root_node(1).boundary(2)...
                    )&&...
                    (root_node(i).boundary(3) == root_node(1).boundary(3)|| ...
                    root_node(i).boundary(4) == root_node(1).boundary(3)|| ...
                    root_node(i).boundary(3) == root_node(1).boundary(4)|| ...
                    root_node(i).boundary(4) == root_node(1).boundary(4)...
                    )...
                    && isempty(root_node(i).children) == 0 ...
                )

                if (have_runned == 0)
                    U_counter_for_name = U_counter_for_name  + 1;
                    have_runned = have_runned + 1;
                end

                counter_for_cell_of_I  = counter_for_cell_of_I  + 1;
                U_list(U_counter_for_name).cell(counter_for_cell_of_I)...
                                            = {root_node(i).children };
                U_list(U_counter_for_name).node= sprintf("%s%c%d%s", root_node, ...
                    '(', 1 ...
                    , ").children");
            end
        end
        
        % U_list(U_counter1).list= [root_node(2).children root_node(3).children
        %                 root_node(4).children ];

        pre_order_traversal(root_node(1).children);

    end

    if isempty(root_node(2).children) == 0
        
        have_runned = 0;
        for i = 1:4
            counter_for_cell_of_I  = 0;
            if (    root_node(i).level == root_node(2).level...
                    && ...
                    (root_node(i).boundary(1) == root_node(2).boundary(1)|| ...
                    root_node(i).boundary(2) == root_node(2).boundary(1)||...
                    root_node(i).boundary(1) == root_node(2).boundary(2)|| ...
                    root_node(i).boundary(2) == root_node(2).boundary(2)...
                    )&&...
                    (root_node(i).boundary(3) == root_node(2).boundary(3)|| ...
                    root_node(i).boundary(4) == root_node(2).boundary(3)|| ...
                    root_node(i).boundary(3) == root_node(2).boundary(4)|| ...
                    root_node(i).boundary(4) == root_node(2).boundary(4)...
                    )...
                    && isempty(root_node(i).children) == 0 ...
                )

                if (have_runned == 0)
                    U_counter_for_name = U_counter_for_name  + 1;
                    have_runned = have_runned + 1;
                end

                counter_for_cell_of_I  = counter_for_cell_of_I  + 1;
                U_list(U_counter_for_name).cell(counter_for_cell_of_I)...
                                            = {root_node(i).children };
                U_list(U_counter_for_name).node= sprintf("%s%c%d%s", root_node, '(', 2 ...
                    , ").children");

            end
        end
        


        
        
        % U_list(U_counter1).list= [root_node(1).children root_node(3).children
        %                 root_node(4).children ];
        % 
        pre_order_traversal(root_node(2).children);

    end

    if isempty(root_node(3).children) == 0

        have_runned = 0;
        for i = 1:4
            counter_for_cell_of_I  = 0;
            if (    root_node(i).level == root_node(3).level...
                    && ...
                    (root_node(i).boundary(1) == root_node(3).boundary(1)|| ...
                    root_node(i).boundary(2) == root_node(3).boundary(1)||...
                    root_node(i).boundary(1) == root_node(3).boundary(2)|| ...
                    root_node(i).boundary(2) == root_node(3).boundary(2)...
                    )&&...
                    (root_node(i).boundary(3) == root_node(3).boundary(3)|| ...
                    root_node(i).boundary(4) == root_node(3).boundary(3)|| ...
                    root_node(i).boundary(3) == root_node(3).boundary(4)|| ...
                    root_node(i).boundary(4) == root_node(3).boundary(4)...
                    )...
                    && isempty(root_node(i).children) == 0 ...
                )

                if (have_runned == 0)
                    U_counter_for_name = U_counter_for_name  + 1;
                    have_runned = have_runned + 1;
                end

                counter_for_cell_of_I  = counter_for_cell_of_I  + 1;
                U_list(U_counter_for_name).cell(counter_for_cell_of_I)...
                                            = {root_node(i).children };
                U_list(U_counter_for_name).node= sprintf("%s%c%d%s", root_node, ...
                    '(', 3 ...
                    , ").children");
            end

        end
        
        
        % U_list(U_counter1).list= [root_node(1).children root_node(2).children
        %                 root_node(4).children ];

        pre_order_traversal(root_node(3).children);

    end

    if isempty(root_node(4).children) == 0

        have_runned = 0;
        for i = 1:4
            counter_for_cell_of_I  = 0;
            if (    root_node(i).level == root_node(4).level...
                    && ...
                    (root_node(i).boundary(1) == root_node(4).boundary(1)|| ...
                    root_node(i).boundary(2) == root_node(4).boundary(1)||...
                    root_node(i).boundary(1) == root_node(4).boundary(2)|| ...
                    root_node(i).boundary(2) == root_node(4).boundary(2)...
                    )&&...
                    (root_node(i).boundary(3) == root_node(4).boundary(3)|| ...
                    root_node(i).boundary(4) == root_node(4).boundary(3)|| ...
                    root_node(i).boundary(3) == root_node(4).boundary(4)|| ...
                    root_node(i).boundary(4) == root_node(4).boundary(4)...
                    )...
                    && isempty(root_node(i).children) == 0 ...
                )

                if (have_runned == 0)
                    U_counter_for_name = U_counter_for_name  + 1;
                    have_runned = have_runned + 1;
                end

                counter_for_cell_of_I  = counter_for_cell_of_I  + 1;
                U_list(U_counter_for_name).cell(counter_for_cell_of_I)...
                                            = {root_node(i).children};
                U_list(U_counter_for_name).node= sprintf("%s%c%d%s", root_node, ...
                    '(', 4 ...
                    , ").children");
            end

        end

        
        % U_list(U_counter1).list= [root_node(1).children root_node(2).children
        %                 root_node(3).children ];

        pre_order_traversal(root_node(4).children);

    end
end



% function quadtree = initialize_quadtree(particles, boundary, max_particles)
%     % particles: 粒子的位置信息
%     % boundary: 節點的邊界 [xmin, xmax, ymin, ymax]
%     % max_particles: 每個節點中最多能容納的粒子數
% 
%     % 如果當前節點的粒子數量超過 max_particles，則分割區域
%     if numel(particles) > max_particles
%         quadtree = struct('children', {}, 'particles', [], 'boundary', []);
%         % 分割成四個區域
%         [region1, region2, region3, region4] = split_boundary(boundary);
%         % 根據位置將粒子分配到各個區域
%         quadtree(1).particles = filter_particles(particles, region1);
%         quadtree(2).particles = filter_particles(particles, region2);
%         quadtree(3).particles = filter_particles(particles, region3);
%         quadtree(4).particles = filter_particles(particles, region4);
% 
%         % 遞迴地為每個子區域建立四叉樹
%         quadtree(1).children = initialize_quadtree(particles1, region1, max_particles);
%         quadtree(2).children = initialize_quadtree(particles2, region2, max_particles);
%         quadtree(3).children = initialize_quadtree(particles3, region3, max_particles);
%         quadtree(4).children = initialize_quadtree(particles4, region4, max_particles);
%     else
%         % 如果粒子數量在可接受範圍內，則不分割
%         quadtree = struct('children', {}, 'particles', particles, 'boundary', boundary);
%     end
% end
% 
% function [region1, region2, region3, region4] = split_boundary(boundary)
%     % 根據當前邊界將其分成四個子區域
%     mid_x = (boundary(1) + boundary(2)) / 2;
%     mid_y = (boundary(3) + boundary(4)) / 2;
% 
%     region1 = [boundary(1), mid_x, boundary(3), mid_y];
%     region2 = [mid_x, boundary(2), boundary(3), mid_y];
%     region3 = [boundary(1), mid_x, mid_y, boundary(4)];
%     region4 = [mid_x, boundary(2), mid_y, boundary(4)];
% end
% 
% function filtered_particles = filter_particles(particles, region)
%     % 過濾出位於 region 內的粒子
%     filtered_particles = particles(particles(:,1) >= region(1) & particles(:,1) <= region(2) & ...
%                                    particles(:,2) >= region(3) & particles(:,2) <= region(4), :);
% end



% 
% 
% Upward pass
% function multipole_expansion = upward_pass(node)
%     如果是葉節點，計算多極展開
%     if isempty(node{})
%         multipole_expansion = compute_multipole(node.particles);
%     else
%         否則，遞迴地計算每個子節點的多極展開，並合併結果
%         multipole_expansion = 0;
%         for i = 1:4
%             child_expansion = upward_pass(node.children{i});
%             multipole_expansion = merge_multipole(multipole_expansion, child_expansion);
%         end
%     end
% end
% 
% 
% function multipole = compute_multipole(particles)
%     根據粒子的位置和劑量值計算多極展開
%     此處可自訂 Chebyshev 插值或其他方法
%     multipole = sum(particles(:, 3));  % 假設第三列是劑量值
% end
% 
% 
% function result = merge_multipole(parent_multipole, child_multipole)
%     合併父節點和子節點的多極展開
%     result = parent_multipole + child_multipole;
% end
% 
% 
% 



% %% Downward pass
% function local_expansion = downward_pass(node, parent_local_expansion)
%     % 計算當前節點的局部展開，從父節點向下傳遞
%     if isempty(node.children)
%         local_expansion = parent_local_expansion + compute_local(node.particles);
%     else
%         % 遞迴地對每個子節點進行局部展開的傳遞
%         for i = 1:4
%             node.children{i}.local_expansion = downward_pass(node.children{i}, parent_local_expansion);
%         end
%     end
% end
% 
% function local = compute_local(particles)
%     % 計算粒子的局部展開
%     local = sum(particles(:, 3));  % 假設第三列是劑量值
% end
% 
% 




% %% Gather
% function energy_distribution = gather(node)
%     if isempty(node.children)
%         % 如果是葉節點，返回能量分佈
%         energy_distribution = compute_energy(node.particles);
%     else
%         % 否則，遞迴地收集每個子節點的能量分佈
%         energy_distribution = 0;
%         for i = 1:4
%             energy_distribution = energy_distribution + gather(node.children{i});
%         end
%     end
% end
% 
% function energy = compute_energy(particles)
%     % 計算每個粒子的最終能量分佈
%     % 假設能量與多極展開和局部展開的結果相關
%     energy = sum(particles(:, 3));  % 假設第三列是劑量值
% end

elapsedTime = toc; % 結束計時並返回所花時間（秒）
fprintf('程式執行時間：%.2f 秒\n', elapsedTime);
